<?xml version="1.0"?>
<doc>
<assembly>
<name>
Databasic
</name>
</assembly>
<members>
<member name="T:Databasic.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Databasic.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Databasic.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:Databasic.ActiveRecord.Entity">
 <summary>
 Active record base class for database models.
 All properties and fields in class extended from this class should be 
 named in the same case sensitive way as columns are named in database.
 Choose fields and properties types to fit into database types.
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetById``1(System.Int64,System.Nullable{System.Int32})">
 <summary>
 Get active record entity instance by autoincrement column, there will be loaded all table columns.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="connectionIndex">Config connection index to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetById``1(System.Int64,System.String)">
 <summary>
 Get active record entity instance by autoincrement column, there will be loaded all table columns.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="connectionName">Config connection name to use different database, default by Databasic.Defaults.CONNECTION_INDEX to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetById``1(System.Int64,Databasic.Connection)">
 <summary>
 Get active record entity instance by autoincrement column, there will be loaded all table columns.
 </summary>
 <typeparam name="TValue">Model class type, inherited from ActiveRecord.</typeparam>
 <param name="connection">Connection intance.</param>
 <exception cref="T:System.Exception">TODO</exception>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.#ctor">
 <summary>
 Automaticly initializes 'Resource' class member (static or instance) with singleton Resource instance, 
 if there is no instance initialized manualy by programmer.
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Entity.initResource">
 <summary>
 Initializes 'Resource' class member (static or instance) with singleton Resource instance,
 if there is no instance yet. This method is always called by Entity constructor.
 </summary>
</member>
<member name="M:Databasic.ActiveRecord.Entity._getReaderRowColumns(System.Data.Common.DbDataReader)">
 <summary>
 Get column names from reader as list of strings.
 </summary>
 <param name="reader"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity._isDescriptableType(System.Type@)">
 <summary>
 Return True if type is descriptable type by custom attributes, not primitive, not an object.
 </summary>
 <param name="instanceType">Instance type to check out.</param>
 <returns>True if descriptable.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity._readerRowToInstance(System.Data.Common.DbDataReader@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo}@,System.Object@,System.Boolean)">
 <summary>
 Set up current reader row columns into instance properties and fields.
 </summary>
 <param name="reader">DbDataReader with current row moved, where current row will be used to fill instance properties and fields.</param>
 <param name="readerColumnNames">Columns in reader in proper order.</param>
 <param name="instance">Instance to fill.</param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.ToDictionary``2(System.Data.Common.DbDataReader,System.String,Databasic.DuplicateKeyBehaviour,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo}@)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as string,
 specify which column from reader to use to complete dictionary keys.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TValue">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="databaseKeyColumnName">Reader column name to use to complete result dictionary keys.</param>
 <param name="duplicateKeyBehaviour">Thrown an Exception if any previous key is already in result set by default, or keep in result set first completed record value or overwrite duplicate key every time with newly completed value.</param>
 <param name="columnsByDbNames">Optional class members meta info, indexed by database column names.</param>
 <returns>Dictionary with keys completed by second param for reader column name, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.ToDictionary``2(System.Data.Common.DbDataReader,System.Func{``1,``0},Databasic.DuplicateKeyBehaviour,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo}@)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as anonymous function,
 specify which field/property from active record instance to use to complete dictionary key for each item.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TValue">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="keySelector">Anonymous function accepting first argument as TActiveRecord instance and returning it's specific field/property value to complete Dictionary key.</param>
 <param name="duplicateKeyBehaviour">Thrown an Exception if any previous key is already in result set by default, or keep in result set first completed record value or overwrite duplicate key every time with newly completed value.</param>
 <param name="columnsByDbNames">Optional class members meta info, indexed by database column names.</param>
 <returns>Dictionary with keys completed by second anonymous function, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.ToList``1(System.Data.Common.DbDataReader,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo}@)">
 <summary>
 Create new Dictionary with instances by generic type and set up all called reader columns into new instances properties or fields.
 If reader has no rows, empty list is returned.
 </summary>
 <typeparam name="TValue">Result list item generic type.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields</param>
 <param name="columnsByDbNames">Optional class members meta info, indexed by database column names.</param>
 <returns>List with values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.ToInstance``1(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Create new instance by generic type and set up all called dictionary keys into new instance properties or fields.
 </summary>
 <typeparam name="TValue">New instance type.</typeparam>
 <param name="data">Data with values for new instance properties and fields.</param>
 <returns>New instance by generic type with values by second param.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.ToInstance``1(System.Data.Common.DbDataReader,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo}@)">
 <summary>
 Create new instance by generic type and set up all called reader columns with one row at minimal into 
 new instance properties or fields. If TResult is primitive type, reader has to return single row and 
 single column select result and that result is converted and returned as to primitive value only.
 If reader has no rows, Nothing is returned.
 </summary>
 <typeparam name="TValue">New result class instance type or any primitive type for single row and single column select result.</typeparam>
 <param name="reader">Reader with values for new instance properties and fields.</param>
 <param name="columnsByDbNames">Optional class members meta info, indexed by database column names.</param>
 <returns>New instance as primitive type or as class instance, completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetValues(System.Collections.Generic.List{System.String},System.Boolean,System.Boolean,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo})">
 <summary>
 Get any properties, fields or reserve store record values from current instance.
 </summary>
 <param name="memberNames">Properties, fields or reserve store value names.</param>
 <param name="keysByCode">If false (by default), get fields/properties values in dictionary with keys by code names, if true, get touched fields in dictionary with keys by database names.</param>
 <param name="asInitialData">Get values from initial store.</param>
 <param name="classMembersInfo">Optional, Databasic meta descriptor info about class members, usualy metaDescription.ColumnsByCodeNames.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.SetUp(System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
 <summary>
 Set up all data from dictionary into current instance properties or fields with or without touching (with touching by default).
 </summary>
 <param name="data">Dictionary with any values, named as instance fields and properties.</param>
 <param name="asInitialData">True to fill data into initial Dictionary to compare them later by GetTouched() function.</param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.GetTouched(System.Boolean,System.Collections.Generic.Dictionary{System.String,Databasic.MemberInfo})">
 <summary>
 Get touched properties and fields in Dictionary. Get everything, what is different 
 to Me._initialData dictionary, filled in instance initial set up.
 </summary>
 <param name="keysByCode">If false (by default), get touched fields in dictionary with keys by code names, if true, get touched fields in dictionary with keys by database names.</param>
 <param name="classMembersInfo">Databasic meta descriptor info about class members, optional.</param>
 <returns>Dictionary with values, which are different from initial set up.</returns>
</member>
<member name="F:Databasic.ActiveRecord.Entity._initialData">
 <summary>
 Properties with values and fields with values touched by indexer.
 </summary>
</member>
<member name="F:Databasic.ActiveRecord.Entity._reserveStore">
 <summary>
 Reserve store to store anything what has been not specified by any property or field.
 </summary>
</member>
<member name="P:Databasic.ActiveRecord.Entity.Item(System.String,System.Boolean)">
 <summary>
 Default member to get/set any value through indexer from/to current instance.
 </summary>
 <param name="memberName">Property, field or reserve store value name.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Get(System.String,System.Boolean,System.Nullable{Databasic.MemberInfo}@)">
 <summary>
 Get any property, field or reserve store record from current instance.
 </summary>
 <param name="memberName">Property, field or reserve store value name.</param>
 <param name="asInitialData">Get value from initial store.</param>
 <param name="memberInfo">Databasic class member info, optional.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Set(System.String,System.Object,System.Boolean,System.Nullable{Databasic.MemberInfo}@)">
 <summary>
 Set any property, field or reserve store value into current instance.
 </summary>
 <param name="memberName">Property, field or reserve store key.</param>
 <param name="value">Property, field or reserve store value.</param>
 <param name="asInitialData">Set value into initial store.</param>
 <param name="memberInfo">Databasic class member info, optional.</param>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
 <summary>
 DynamicObject overloading method implementing reading nondeclared values from Me._reserveStore.
 </summary>
 <param name="binder"></param>
 <param name="result"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
 <summary>
 DynamicObject overloading method implementing writing nondeclared values into Me._reserveStore.
 </summary>
 <param name="binder"></param>
 <param name="value"></param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Delete(System.Int32)">
 <summary>
 Delete ActiveRecord instance by instance Id property (Id database column).
 </summary>
 <param name="connectionIndex">Config connection index to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Delete(System.String)">
 <summary>
 Delete ActiveRecord instance by instance Id property (Id database column)
 </summary>
 <param name="connectionName">Config connection name to use different database, default by 0 to use first connection in &lt;connectionStrings&gt; list.</param>
 <returns></returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Table(System.Type,System.Int32)">
 <summary>
 Get declared table name by 'activeRecordType' and by optional called index argument.
 </summary>
 <param name="activeRecordType">Class type, inherited from ActiveRecord class with declared protected static field 'tables' as array of strings.</param>
 <param name="tableIndex">Array index to get proper table name string from declared protected static field 'tables' as array of strings.</param>
 <returns>Declared database table name from active record class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Entity.Table``1(System.Int32)">
 <summary>
 Get declared table name from generic type 'TActiveRecord' and by optional called index argument.
 </summary>
 <typeparam name="TActiveRecord">Class name, inherited from ActiveRecord class with declared protected static field 'tables' as array of strings.</typeparam>
 <param name="tableIndex">Array index to get proper table name string from declared protected static field 'tables' as array of strings.</param>
 <returns>Declared database table name from active record class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Resource.Table(System.Type@,System.Int32)">
 <summary>
 Get declared table name by 'resourceType' and by optional called index argument.
 </summary>
 <param name="resourceType">Class type, inherited from Resource class with declared protected static field 'tables' as array of strings.</param>
 <param name="tableIndex">Array index to get proper table name string from declared protected override property 'tables' as array of strings.</param>
 <returns>Declared database table name from resource class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Resource.Table``1(System.Int32)">
 <summary>
 Get declared table name from generic type 'TResource' and by optional called index argument.
 </summary>
 <typeparam name="TResource">Class name, inherited from Resource class with declared protected static field 'tables' as array of strings.</typeparam>
 <param name="tableIndex">Array index to get proper table name string from declared protected override property 'tables' as array of strings.</param>
 <returns>Declared database table name from resource class.</returns>
</member>
<member name="M:Databasic.ActiveRecord.Resource.Table(System.Int32)">
 <summary>
 Get declared table name from called class attribute and by optional called index argument.
 </summary>
 <param name="tableIndex">Array index to get proper table name string from declared protected override property 'tables' as array of strings.</param>
 <returns>Declared database table name from resource class.</returns>
</member>
<member name="M:Databasic.Connection.RegisterConfigRecord(System.String,System.String,System.String,System.Boolean)">
 <summary>
 Register any connection string for databasic models and queries which doesn't exist in application config file.
 </summary>
 <param name="name">Connection string unique name, the same name used in your model classes in Databasic.Connection("name") class attribute.</param>
 <param name="connectionString">DSN connection string value.</param>
 <param name="providerName">Database provider supported by databasic library.</param>
 <param name="overwriteExisting">Overwrite already existing connection string under given name in databasic config values internal register.</param>
</member>
<member name="M:Databasic.Connection.RegisterConfigRecord(System.String,System.String,Databasic.ProviderName,System.Boolean)">
 <summary>
 Register any connection string for databasic models and queries which doesn't exist in application config file.
 </summary>
 <param name="name">Connection string unique name, the same name used in your model classes in Databasic.Connection("name") class attribute.</param>
 <param name="connectionString">DSN connection string value.</param>
 <param name="providerName">Database provider supported by databasic library.</param>
 <param name="overwriteExisting">Overwrite already existing connection string under given name in databasic config values internal register.</param>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on first config connection.
 </summary>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.Int32,System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on specified connection config index.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="M:Databasic.Connection.BeginTransaction(System.String,System.String,Databasic.IsolationLevel)">
 <summary>
 Create and begin transaction on specified connection config name.
 </summary>
 <param name="connectionName">Config connection name.</param>
 <param name="transactionName">Transaction name.</param>
 <param name="isolationLevel">Transaction isolation level.</param>
 <returns>New transaction.</returns>
</member>
<member name="M:Databasic.Connection.Open(System.String)">
 <summary>
 Create and open new connection and set it into Provider property, register InfoMessage handler.
 This procedure is not necessary to call manualy, it's automaticly called internaly by first <c>Connection.Get()</c> call.
 </summary>
 <param name="dsn">Database dsn connection string, usually with server address, username and password.</param>
</member>
<member name="M:Databasic.Connection.Get(System.Nullable{System.Int32})">
 <summary>
 Get (and open if necessary) registered connection instance by config index, internaly by process id and thread id.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <returns>New opened or existing connection instance with registered InfoMessage handler, registered in internal store.</returns>
</member>
<member name="M:Databasic.Connection.Get(System.String)">
 <summary>
 Get and open connection by config name.
 </summary>
 <param name="connectionName">Config connection name.</param>
 <returns></returns>
</member>
<member name="M:Databasic.Connection._createAndOpen(System.Int32)">
 <summary>
 Create new connection instance by connection index and returns it
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <returns>New opened connection instance with registered InfoMessage handler.</returns>
</member>
<member name="F:Databasic.Connection._registerLock">
 <summary>
 Threads semahore to read/write first level records from/into managed connections store.
 </summary>
</member>
<member name="F:Databasic.Connection._registerLocks">
 <summary>
 Threads semahores to read/write second level records from/into managed connections store.
 </summary>
</member>
<member name="M:Databasic.Connection.Close">
 <summary>
 Close and drop all connections for current process and thread.
 Call this method always at thread end.
 </summary>
</member>
<member name="M:Databasic.Connection.Close(System.Int32)">
 <summary>
 Close and drop connection by config index for current process and thread.
 Call this method always after you have loaded all from any secondary database.
 </summary>
 <param name="connectionIndex">Config connection index.</param>
</member>
<member name="M:Databasic.Connection.Close(System.String)">
 <summary>
 Close and drop connection by config name for current process And thread.
 Call this method always after you have loaded all from any secondary database.
 </summary>
 <param name="connectionName">Config connection name.</param>
</member>
<member name="M:Databasic.Connection.Close(System.Int32,System.Int32,System.Int32)">
 <summary>
 Close and drop connection by config index for specificly called process and thread.
 Call this method only if you know what you are doing:-)
 </summary>
 <param name="connectionIndex">Config connection index.</param>
 <param name="processId">Specific process id.</param>
 <param name="threadId">Specific thread id.</param>
</member>
<member name="M:Databasic.Connection.CloseAllInProcess(System.Int32)">
 <summary>
 Close and drop connections for specificly called process.
 </summary>
</member>
<member name="P:Databasic.Connection.ProviderVersion">
 <summary>
 ADO.NET provider asembly version.
 </summary>
</member>
<member name="P:Databasic.Connection.ConnectionIndex">
 <summary>
 Config connection index.
 </summary>
</member>
<member name="P:Databasic.Connection.Provider">
 <summary>
 ADO.NET connection instance.
 </summary>
</member>
<member name="P:Databasic.Connection.ProviderResource">
 <summary>
 Provider resource type to create specific resource class for common database operations.
 </summary>
</member>
<member name="P:Databasic.Connection.ClientName">
 <summary>
 Client assembly name used by specific connection implementation.
 </summary>
</member>
<member name="P:Databasic.Connection.Statement">
 <summary>
 ADO.NET statement type.
 </summary>
</member>
<member name="F:Databasic.Connection.Config">
 <summary>
 Parsed subnode values from node &lt;connectionStrings&gt; in (App|Web).config file.
 </summary>
</member>
<member name="F:Databasic.Connection.NamesAndIndexes">
 <summary>
 (App|Web).config connection names with their indexes.
 </summary>
</member>
<member name="F:Databasic.Connection._staticInitDoneLock">
 <summary>
 Threads semahore to read/write into managed connections store.
 </summary>
</member>
<member name="F:Databasic.Connection._staticInitDone">
 <summary>
 True if static initialization completed, nothing else.
 </summary>
</member>
<member name="F:Databasic.Connection._supportedProviders">
 <summary>
 Supported database providers.
 </summary>
</member>
<member name="F:Databasic.Connection._providersResources">
 <summary>
 Supported database providers resource instances.
 </summary>
</member>
<member name="F:Databasic.Connection._connectionsRegister">
 <summary>
 All Databasic connections managed store for all processes and for all threads.
 </summary>
</member>
<member name="M:Databasic.Connection.GetIndexByName(System.String,System.Boolean)">
 <summary>
 Get config connection index (sequence index) by connection name.
 </summary>
 <param name="connectionName">Connection name dictionary key.</param>
 <returns>Config connection index (sequence index).</returns>
</member>
<member name="M:Databasic.Connection._getProcessAndThreadKey">
 <summary>
 Return string as combination of current process id, underscore char and thread id.
 </summary>
 <returns>String as combination of current process id, underscore char and thread id.</returns>
</member>
<member name="M:Databasic.Connection.GetProviderResource">
 <summary>
 Get specific database implementation ProviderResource class instance by connection client name.
 </summary>
 <returns>Specific database inmplementation ProviderResource instance.</returns>
</member>
<member name="M:Databasic.Connection.#cctor">
 <summary>
 Load config and set up connection strings.
 </summary>
</member>
<member name="T:Databasic.ErrorHandler">
 <summary>
 Typed handler for catched Databasic utility exception or sql server error(s).
 </summary>
 <param name="ex">Catched Exception In .NET environment.</param>
 <param name="sqlErrors">Collection of SQL errors sended from SQL server.</param>
</member>
<member name="F:Databasic.ProviderName.MsSql">
 <summary>
 Microsoft SQL server - System.Data.SqlClient
 </summary>
</member>
<member name="F:Databasic.ProviderName.MySql">
 <summary>
 MariaDB/MySQL server - MySql.Data.MySqlClient
 </summary>
</member>
<member name="F:Databasic.ProviderName.OdbcSql">
 <summary>
 ODBC server - System.Data.Odbc
 </summary>
</member>
<member name="F:Databasic.ProviderName.OleSql">
 <summary>
 ODBC server - System.Data.Odbc
 </summary>
</member>
<member name="F:Databasic.ProviderName.OracleSql">
 <summary>
 OLE database or server - Oracle.DataAccess.Client
 </summary>
</member>
<member name="F:Databasic.ProviderName.PostgreSQL">
 <summary>
 PostreSql server - Npgsql
 </summary>
</member>
<member name="F:Databasic.ProviderName.SQLite">
 <summary>
 SQLite database - System.Data.SQLite
 </summary>
</member>
<member name="M:Databasic.Tools.GetTypeGlobaly(System.String)">
 <summary>
 Return Type object by sstring in forms: "Full.Class.Name" or "AssemblyName:Full.Class.Name"
 </summary>
 <param name="fullClassName" type="String">"Full.Class.Name" or "AssemblyName:Full.Class.Name"</param>
 <returns type="Type">Desired type</returns>
</member>
<member name="M:Databasic.Tools.GetTypeGlobaly(System.String,System.String)">
 <summary>
 Return Type object by two strings in form: "AssemblyName", "Full.Class.Name"
 </summary>
 <param name="assemblyName" type="String">"AssemblyName" for AssemblyName.dll</param>
 <param name="fullClassName" type="String">Full class name including namespace</param>
 <returns type="Type">Desired type</returns>
</member>
<member name="E:Databasic.Events.Error">
 <summary>
 Custom error handler to print or log any database error.
 </summary>
</member>
<member name="F:Databasic.Constants.StringTypeCode">
 <summary>
 String type code value, used frequently in Entity._readerRowToInstance.
 </summary>
</member>
<member name="P:Databasic.Statement.Command">
 <summary>
 Currently prepared and executed SQL command.
 </summary>
</member>
<member name="P:Databasic.Statement.Reader">
 <summary>
 Currently executed data reader from SQL command.
 </summary>
</member>
<member name="M:Databasic.Statement.#ctor(System.String,System.Data.Common.DbConnection)">
 <summary>
 Empty SQL statement constructor.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="connection">Connection instance.</param>
</member>
<member name="M:Databasic.Statement.#ctor(System.String,System.Data.Common.DbTransaction)">
 <summary>
 Empty SQL statement constructor.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="transaction">SQL transaction instance with connection instance inside.</param>
</member>
<member name="M:Databasic.Statement.PrepareLocal(System.String,Databasic.Connection)">
 <summary>
 Create proper type of SQL statement by connection type.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="connection">Connection instance.</param>
 <returns>New specificly typed SQL statement.</returns>
</member>
<member name="M:Databasic.Statement.PrepareLocal(System.String,Databasic.Transaction)">
 <summary>
 Create proper type of SQL statement by connection type.
 </summary>
 <param name="sql">SQL statement code.</param>
 <param name="transaction">SQL transaction instance with connection instance inside.</param>
 <returns>New specificly typed SQL statement.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,System.Nullable{System.Int32})">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="connectionIndex">
 Database connection index from App|Web.config to use specific database connection, 
 default value is 0 to use first connection settings subnode from &lt;connectionStrings&gt; config node.
 </param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,System.String)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 Database connection name from App|Web.config to use specific database connection, 
 default value is 'DefaultConnection' to use default connection settings subnode from &lt;connectionStrings&gt; config node.
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,Databasic.Connection)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="connection">Your specific database connection instance to execute this SQL statement inside.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,Databasic.Transaction)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 Created database statement will be executed in passed transaction.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="transaction">Database transaction from current connection to execute this SQL statement inside.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.Prepare(System.String,System.Object)">
 <summary>
 Create and prepare database SQL statement. Put '@' char before all param names in your SQL code.
 Created database statement will be executed in passed transaction.
 </summary>
 <param name="sql">SQL code for statement. Put '@' char before all param names in your SQL code.</param>
 <param name="connectionOrTransaction">Database connection or database transaction from current connection to execute this SQL statement inside.</param>
 <returns>New specificly typed SQL statement by connection.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne(System.Object)">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchOne(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Execute SQL statement and open data reader to get only first single row from select statement result.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(System.Object,Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.FetchAll(System.Collections.Generic.Dictionary{System.String,System.Object},Databasic.CommandBehavior)">
 <summary>
 Execute SQL statement and open data reader to get all rows from select statement result.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <param name="commandBehavior">SQL data reader command behaviour, optional.</param>
 <returns>SQL statement instance with opened data reader.</returns>
</member>
<member name="M:Databasic.Statement.Exec">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.Exec(System.Object)">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.Exec(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Execute any non select SQL statement and return affected rows count.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
 <returns>Affected rows count.</returns>
</member>
<member name="M:Databasic.Statement.ToInstance``1">
 <summary>
 Create new instance by generic type and set up all called reader columns with one row at minimal into 
 new instance properties or fields. If TResult is primitive type, reader has to return single row and 
 single column select result and that result is converted and returned as to primitive value only.
 If reader has no rows, Nothing is returned.
 </summary>
 <typeparam name="TResult">New result class instance type or any primitive type for single row and single column select result.</typeparam>
 <returns>New instance by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToList``1">
 <summary>
 Create List of desired class instance types or List of variables from singlerow 
 or multirow and single column or multi column select result.
 Specify result class instance type or result variable type by generic argument.
 If reader has no rows, empty list is returned.
 </summary>
 <typeparam name="TActiveRecord">Result List item generic type.</typeparam>
 <returns>List of new instances/variables by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToDictionary``2(System.String,System.Boolean)">
 <summary>
 Create Dictionary of values by desired class instance types or Dictionary of values by variables 
 from singlerow or multirow and single column or multi column select result. 
 Specify result Dictionary key type by first generic argument.
 Specify result Dictionary value class instance type or result Dictionary value variable type by second generic argument.
 Specify which column from select result to use to complete dictionary keys by first string param.
 If reader has no rows, empty Dictionary is returned.
 </summary>
 <typeparam name="TKey">Result Dictionary generic type to complete Dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result Dictionary generic type to complete Dictionary values.</typeparam>
 <param name="databaseKeyColumnName">Reader column name to use to complete result dictionary keys.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by completing the result Dictionary, False to overwrite any previous value in Dictionary, True by default.</param>
 <returns>Dictionary of new instances/variables by generic type with values by generic argument.</returns>
</member>
<member name="M:Databasic.Statement.ToDictionary``2(System.Func{``1,``0},System.Boolean)">
 <summary>
 Create new Dictionary with keys by first generic type and instances (values) by second generic type 
 and set up all called reader columns into new instances properties or fields. By first param as anonymous function,
 specify which field/property from active record instance to use to complete dictionary key for each item.
 If reader has no rows, empty dictionary is returned.
 </summary>
 <typeparam name="TKey">Result dictionary generic type to complete dictionary keys.</typeparam>
 <typeparam name="TActiveRecord">Result dictionary generic type to complete dictionary values.</typeparam>
 <param name="keySelector">Anonymous function accepting first argument as TActiveRecord instance and returning it's specific field/property value to complete Dictionary key.</param>
 <param name="throwExceptionInDuplicateKey">True to thrown Exception if any previous key will be founded by filling the result, false to overwrite any previous value.</param>
 <returns>Dictionary with keys completed by second anonymous function, values completed by reader columns with the same names as TActiveRecord type fields/properties.</returns>
</member>
<member name="M:Databasic.Statement.addParamsWithValue(System.Object)">
 <summary>
 Set up all sql params into internal Command instance.
 </summary>
 <param name="sqlParams">Anonymous object with named keys as SQL statement params without any '@' chars in object keys.</param>
</member>
<member name="M:Databasic.Statement.addParamsWithValue(System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 Set up all sql params into internal Command instance.
 </summary>
 <param name="sqlParams">Dictionary with named keys as SQL statement params without any '@' chars in dictionary keys.</param>
</member>
</members>
</doc>
